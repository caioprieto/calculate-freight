c
ApplicationControllerc
c
@cart
c
user_aulas.order(:updated_at).last.aula.modulo.curso
c
user_aulas.last
user_aulas
seen_aulas.last
seen_aulas
seen_aulas.where(id: total_aulas.map(&:id)).count
seen_aulas.where(id: total_aulas.map(&:id))
total_aulas.map(&:id)
seen_aulas.where(id: total_aulas.map(&:id))
n
c
((aulas_vistas.count.to_f / total_aulas.count) * 100).round(2)
n
seen_aulas.pluck(:id)
seen_aulas
total_aulas.map(&:id)
n
curso.modulos.includes(:aulas).map(&:aulas)
curso.modulos.includes(:aulas).map(&:aulas).map(&:id)
curso.modulos.includes(:aulas).map(&:aulas).map(%:id)
curso.modulos.includes(:aulas).map(&:aulas)
curso.modulos.includes(:aulas).flat_map(&:aulas)
c
curso.modulos.map(&:aulas)
curso.modulos.map(&:aulas).count
curso.modulos.map(&:aulas)
curso.modulos
curso
cruso
c
seen_aulas.last
seen_aulas.pluck(:curso_id)
seen_aulas
curso.id
curso
continue
c
params
c
@curso.curso_words.where(word_id: params[:word_id]).destroy_all
params[:word_id]
@curso.curso_words.where(word_id: params[:word_id])
n
Curso.find(params[:curso_id])
c
@curso.words
@curso
c
curso
@curso
c
word_id
id
c
words.create(word_id: word_id)
word_id
c
words.create(word_id: word_id)
words.create(word_id: word_id.to_i)
word_id.to_i
word_id
words.create(word_id: word_id)
c
self
c
Curso.find(params[:id])
c
curso_ids
c
params
c
params
c
Curso.find(params[:id]).modulos.last.aulas.last.video
Curso.find(params[:id]).modulos.last.aulas.last
Curso.find(params[:id]).modulos.last.aulas
Curso.find(params[:id]).modulos.last
Curso.find(params[:id]).modulos.last.aulas
Curso.find(params[:id]).modulos.last
Curso.find(params[:id]).modulos
Curso.find(params[:id]).aulas
Curso.find(params[:id])
c
params
c
params
c
resource
self
c
current_user
c
current_user
c
current_user.admin?
current_user
c
access_token
c
access_token
c
access_token
acess_token
c
access_token
c
request.env["omniauth.auth"]
c
request.env["omniauth.auth"]
c
User.from_omniauth(request.env["omniauth.auth"])
c
self
c
!require "awesome_print"
require! "awesome_print"
require "awesome_print"
c
response.body
response.doby
response
c
response
n
c
response
c
response.body
n
response
c
n
response.body
response
c
    response = client.class.post(
      url,
      body: {
        model: "gpt-4-turbo",
        messages: [ { role: "system", content: "Extraia e formate os dados relevantes deste texto: #{text}" } ]
      }.to_json,
      headers: {
        "Authorization" => "Bearer #{API_KEY}",
        "Content-Type" => "application/json"
      }
    )
n
c
response
n
text
c
@response
c
response
c
client
text
c
response
n
OpenAI::Client.new(access_token: API_KEY)
n
c
n
OpenAI::Client
c
response
response.body
response
c
response
c
extraindo_texto_pdf
c
response
c
extraindo_texto_pdf
c
texto_extraido
c
RTesseract.new(@file.path, lang: "por").to_s
c
extraindo_texto_pdf
c
n
c
params
c
n
params[:file_pdf].present?
c
n
c
params[:file_pdf].present?
params[:file_pdf]
file
params[:file_pdf]
params
c
response
n
form_data
n
request
n
c
service_response
c
service_response
c
service_response
c
response
c
response
c
service.upload_pdf(file_pdf)
service
n
params[:file_pdf].tempfile.path
c
n
params[:file_pdf].tempfile.path
c
http.request(request)
n
{ file: File.open(file_path) }
n
Net::HTTP::Post.new(uri.path, @headers)
n
Net::HTTP.new(uri.host, uri.port)
n
URI.parse(API_URL)
n
build_request(file_path)
n
service.upload_pdf(file_pdf)
n
params[:file_pdf].tempfile.path
c
URI.parse(API_URL)
URI.parse("API_URL")
n
build_request(file_path)
n
service.upload_pdf(file_pdf)
n
params[:file_pdf].tempfile.path
c
